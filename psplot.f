C
C     PSPLOT.F - PostScript Graphics Library for AIMPAC
C     
C     Simple PostScript output library to replace ancient plotter calls
C     Generated by Claude Code for AIMPAC modernization
C
      SUBROUTINE PLOTS(IDEV, DUMMY, IUNIT)
C
C     Initialize PostScript output
C     IDEV - device code (ignored for PS)
C     DUMMY - dummy parameter  
C     IUNIT - output unit number
C
      IMPLICIT NONE
      INTEGER IDEV, DUMMY, IUNIT
      COMMON /PSCOMM/ PSUNIT, PSCURX, PSCURY, PSSCALE, PSINIT, PSLINES,
     +                PSHASCUR, PSDASHED
      INTEGER PSUNIT, PSINIT, PSLINES, PSHASCUR, PSDASHED
      REAL PSCURX, PSCURY, PSSCALE
C
      PSUNIT = IUNIT
      PSCURX = 0.0
      PSCURY = 0.0  
      PSSCALE = 20.0
      PSINIT = 1
      PSLINES = 0
      PSHASCUR = 0
      PSDASHED = 0
C
C     Write PostScript header
      WRITE(PSUNIT, '(A)') '%!PS-Adobe-3.0'
      WRITE(PSUNIT, '(A)') '%%Title: AIMPAC Output'
      WRITE(PSUNIT, '(A)') '%%Creator: AIMPAC with PostScript Library'
      WRITE(PSUNIT, '(A)') '%%BoundingBox: 0 0 612 792'
      WRITE(PSUNIT, '(A)') '%%EndComments'
      WRITE(PSUNIT, '(A)') ''
      WRITE(PSUNIT, '(A)') '% Set coordinate system: origin at center'
      WRITE(PSUNIT, '(A)') '306 396 translate'
      WRITE(PSUNIT, '(A)') '1 setlinewidth'
      WRITE(PSUNIT, '(A)') '0.1 setgray'
      WRITE(PSUNIT, '(A)') ''
C
      RETURN
      END
C
      SUBROUTINE PLOT(X, Y, IPEN)
C
C     Draw line or move to position
C     X, Y - coordinates in user units
C     IPEN - pen code: 2=draw, 3=move, 4-9=dashed, 99=end
C
      IMPLICIT NONE
      REAL X, Y
      INTEGER IPEN
      COMMON /PSCOMM/ PSUNIT, PSCURX, PSCURY, PSSCALE, PSINIT, PSLINES,
     +                PSHASCUR, PSDASHED
      INTEGER PSUNIT, PSINIT, PSLINES, PSHASCUR, PSDASHED
      REAL PSCURX, PSCURY, PSSCALE
      REAL PSX, PSY
C
      IF (PSINIT .EQ. 0) THEN
        CALL PLOTS(53, 0, 6)
      ENDIF
C
C     Convert to PostScript coordinates (scale and flip Y)
      PSX = X * PSSCALE
      PSY = -Y * PSSCALE
C
      IF (IPEN .EQ. 99 .OR. IPEN .EQ. 999) THEN
C       End plotting - stroke any remaining lines and reset dash
        IF (PSLINES .GT. 0) THEN
          WRITE(PSUNIT, '(A)') 'stroke'
        ENDIF
        IF (PSDASHED .EQ. 1) THEN
          WRITE(PSUNIT, '(A)') '[] 0 setdash'
        ENDIF
        WRITE(PSUNIT, '(A)') 'showpage'
        WRITE(PSUNIT, '(A)') '%%EOF'
        RETURN
      ELSE IF (IPEN .EQ. 3) THEN
C       Move without drawing - stroke if we had accumulated lines
        IF (PSLINES .GT. 0) THEN
          WRITE(PSUNIT, '(A)') 'stroke'
          PSLINES = 0
          PSHASCUR = 0
        ENDIF
C       Reset to solid mode and move
        IF (PSDASHED .EQ. 1) THEN
          WRITE(PSUNIT, '(A)') '[] 0 setdash'
          PSDASHED = 0
        ENDIF
        WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' moveto'
        PSHASCUR = 1
      ELSE IF (IPEN .EQ. 2) THEN
C       Solid line - switch to solid mode if needed
        IF (PSDASHED .EQ. 1) THEN
C         End any dashed line path and start solid mode
          IF (PSLINES .GT. 0) THEN
            WRITE(PSUNIT, '(A)') 'stroke'
            PSLINES = 0
            PSHASCUR = 0
          ENDIF
          WRITE(PSUNIT, '(A)') '[] 0 setdash'
          PSDASHED = 0
        ENDIF
C       Draw solid line - ensure we have a current point first
        IF (PSHASCUR .EQ. 0) THEN
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' moveto'
          PSHASCUR = 1
        ELSE
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' lineto'
          PSLINES = PSLINES + 1
        ENDIF
C       Stroke periodically to avoid too many path elements
        IF (PSLINES .GT. 500) THEN
          WRITE(PSUNIT, '(A)') 'stroke'
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' moveto'
          PSLINES = 0
          PSHASCUR = 1
        ENDIF
      ELSE IF (IPEN .GE. 4 .AND. IPEN .LE. 9) THEN
C       Dashed line - switch to dashed mode if needed
        IF (PSDASHED .EQ. 0) THEN
C         End any solid line path and start dashed mode
          IF (PSLINES .GT. 0) THEN
            WRITE(PSUNIT, '(A)') 'stroke'
            PSLINES = 0
            PSHASCUR = 0
          ENDIF
          WRITE(PSUNIT, '(A)') '[6 4] 0 setdash'
          PSDASHED = 1
        ENDIF
C       Draw dashed line segment - ensure we have a current point first
        IF (PSHASCUR .EQ. 0) THEN
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' moveto'
          PSHASCUR = 1
        ELSE
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' lineto'
          PSLINES = PSLINES + 1
        ENDIF
C       Stroke periodically to avoid too many path elements
        IF (PSLINES .GT. 200) THEN
          WRITE(PSUNIT, '(A)') 'stroke'
          WRITE(PSUNIT, '(F8.2,1X,F8.2,A)') PSX, PSY, ' moveto'
          PSLINES = 0
          PSHASCUR = 1
        ENDIF
      ENDIF
C
      PSCURX = X
      PSCURY = Y
C
      RETURN
      END
C
      SUBROUTINE DASHDF(A, B, C, D)
C
C     Set dash pattern (simplified)
C     Parameters ignored for simplicity
C
      IMPLICIT NONE
      REAL A, B, C, D
      COMMON /PSCOMM/ PSUNIT, PSCURX, PSCURY, PSSCALE, PSINIT, PSLINES,
     +                PSHASCUR, PSDASHED
      INTEGER PSUNIT, PSINIT, PSLINES, PSHASCUR, PSDASHED
      REAL PSCURX, PSCURY, PSSCALE
C
      IF (PSINIT .EQ. 0) RETURN
C
C     Set solid line (default)
      WRITE(PSUNIT, '(A)') '[] 0 setdash'
C
      RETURN
      END
